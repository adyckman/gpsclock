#!/usr/bin/env python3
"""Generate timezone grid data for the GPS clock.

Creates src/tz_grid.py with a compact boundary-per-row representation
of US timezone boundaries at 0.25-degree latitude resolution.

For each latitude row, three longitude boundaries are stored:
  Pacific/Mountain, Mountain/Central, Central/Eastern
This encodes the same information as a full grid but in only 312 bytes.

Usage: python3 utils/gen_tz_grid.py
"""

import os

LAT_MIN = 24.0
LAT_MAX = 50.0
LON_MIN = -125.0
STEP = 0.25
ROWS = int((LAT_MAX - LAT_MIN) / STEP)  # 104


def pm_boundary(lat):
    """Pacific/Mountain boundary longitude (west of this = Pacific)."""
    if lat < 32.5:
        return -125.0   # No Pacific time on mainland US below ~32.5N
    elif lat < 36.0:
        return -114.6   # CA/AZ border (Colorado River)
    elif lat < 42.0:
        return -114.0   # NV/UT border
    elif lat < 46.0:
        return -116.8   # OR/ID border
    else:
        return -117.0   # WA/ID border


def mc_boundary(lat):
    """Mountain/Central boundary longitude (west of this = Mountain)."""
    if lat < 30.5:
        return -125.0   # No Mountain time below ~30.5N
    elif lat < 32.0:
        return -104.5   # TX Mountain area (El Paso / Hudspeth)
    elif lat < 37.0:
        return -103.0   # NM eastern border
    elif lat < 41.0:
        return -102.0   # CO eastern border
    else:
        return -104.0   # WY / MT / ND / SD


def ce_boundary(lat):
    """Central/Eastern boundary longitude (west of this = Central)."""
    if lat < 25.0:
        return -81.5    # FL Keys area
    elif lat < 29.5:
        return -85.0    # FL panhandle / Gulf coast
    elif lat < 31.0:
        return -85.5    # AL/FL panhandle
    elif lat < 35.0:
        return -85.0    # AL/GA border, TN/GA
    elif lat < 37.0:
        return -85.3    # TN (east TN is Eastern)
    elif lat < 38.5:
        return -86.0    # KY (Louisville is Eastern at -85.76)
    elif lat < 39.5:
        return -86.5    # KY/IN transition
    elif lat < 43.5:
        return -87.5    # IN/IL border (most of IN is Eastern)
    elif lat < 45.5:
        return -87.5    # MI UP / WI
    elif lat < 47.5:
        return -88.0    # Northern WI / MI UP
    else:
        return -89.0    # MN / northern border


def lon_to_offset(lon):
    """Convert longitude to byte offset from LON_MIN in STEP units."""
    offset = round((lon - LON_MIN) / STEP)
    return max(0, min(255, offset))


def generate():
    """Generate the boundary byte array."""
    data = bytearray()
    for row in range(ROWS):
        lat = LAT_MIN + row * STEP
        data.append(lon_to_offset(pm_boundary(lat)))
        data.append(lon_to_offset(mc_boundary(lat)))
        data.append(lon_to_offset(ce_boundary(lat)))
    return bytes(data)


def format_bytes(data, per_line=15):
    """Format bytes as concatenated Python bytes literals."""
    lines = []
    for i in range(0, len(data), per_line):
        chunk = data[i:i + per_line]
        hex_str = ''.join('\\x{:02x}'.format(b) for b in chunk)
        lines.append("    b'{}'".format(hex_str))
    return '\n'.join(lines)


def main():
    data = generate()

    script_dir = os.path.dirname(os.path.abspath(__file__))
    out_path = os.path.join(script_dir, '..', 'src', 'tz_grid.py')
    out_path = os.path.normpath(out_path)

    content = '"""Precomputed US timezone boundary grid at 0.25-degree resolution.\n'
    content += '\n'
    content += 'Auto-generated by utils/gen_tz_grid.py -- do not edit manually.\n'
    content += '"""\n'
    content += '\n'
    content += 'LAT_MIN = 24.0\n'
    content += 'LAT_MAX = 50.0\n'
    content += 'LON_MIN = -125.0\n'
    content += 'STEP = 0.25\n'
    content += 'ROWS = {}\n'.format(ROWS)
    content += '\n'
    content += '# Arizona bounds (Mountain Standard Time, no DST)\n'
    content += 'AZ_LAT_S = 31.33\n'
    content += 'AZ_LAT_N = 37.0\n'
    content += 'AZ_LON_W = -114.82\n'
    content += 'AZ_LON_E = -109.04\n'
    content += '\n'
    content += '# Boundary data: 3 bytes per latitude row\n'
    content += '# [Pacific/Mountain, Mountain/Central, Central/Eastern]\n'
    content += '# Each byte = longitude offset from LON_MIN in STEP-degree units\n'
    content += '_B = (\n'
    content += format_bytes(data) + '\n'
    content += ')\n'
    content += '\n'
    content += '\n'
    content += 'def lookup(lat, lon):\n'
    content += '    """Look up timezone index from GPS coordinates.\n'
    content += '\n'
    content += '    Returns index into timezone._ZONES (0-6), or -1 if outside grid.\n'
    content += '    0=Eastern 1=Central 2=Mountain 3=Arizona 4=Pacific 5=Alaska 6=Hawaii\n'
    content += '    """\n'
    content += '    if lat > 54.0 and lon < -130.0:\n'
    content += '        return 5\n'
    content += '    if lat < 23.5 and lon < -154.0:\n'
    content += '        return 6\n'
    content += '    if lat < LAT_MIN or lat >= LAT_MAX or lon < LON_MIN or lon > -66.5:\n'
    content += '        return -1\n'
    content += '    row = int((lat - LAT_MIN) / STEP)\n'
    content += '    if row >= ROWS:\n'
    content += '        row = ROWS - 1\n'
    content += '    col = (lon - LON_MIN) / STEP\n'
    content += '    i = row * 3\n'
    content += '    if col < _B[i]:\n'
    content += '        return 4\n'
    content += '    if col < _B[i + 1]:\n'
    content += '        if AZ_LAT_S <= lat <= AZ_LAT_N and AZ_LON_W <= lon <= AZ_LON_E:\n'
    content += '            return 3\n'
    content += '        return 2\n'
    content += '    if col < _B[i + 2]:\n'
    content += '        return 1\n'
    content += '    return 0\n'

    with open(out_path, 'w') as f:
        f.write(content)

    print("Wrote {} ({} bytes of boundary data, {} rows)".format(
        out_path, len(data), ROWS))

    # Print a few sample lookups for verification
    samples = [
        ("New York, NY", 40.71, -74.01),
        ("Chicago, IL", 41.88, -87.63),
        ("Denver, CO", 39.74, -104.99),
        ("Phoenix, AZ", 33.45, -112.07),
        ("Los Angeles, CA", 34.05, -118.24),
        ("Anchorage, AK", 61.22, -149.90),
        ("Honolulu, HI", 21.31, -157.86),
        ("El Paso, TX", 31.76, -106.44),
        ("Nashville, TN", 36.16, -86.78),
        ("Louisville, KY", 38.25, -85.76),
    ]
    names = ["Eastern", "Central", "Mountain", "Arizona", "Pacific", "Alaska", "Hawaii"]
    print("\nSample lookups:")
    for name, lat, lon in samples:
        # Inline lookup for verification
        if lat > 54.0 and lon < -130.0:
            idx = 5
        elif lat < 23.5 and lon < -154.0:
            idx = 6
        elif lat < LAT_MIN or lat >= LAT_MAX or lon < LON_MIN or lon > -66.5:
            idx = -1
        else:
            row = int((lat - LAT_MIN) / STEP)
            if row >= ROWS:
                row = ROWS - 1
            col_val = (lon - LON_MIN) / STEP
            i = row * 3
            if col_val < data[i]:
                idx = 4
            elif col_val < data[i + 1]:
                if 31.33 <= lat <= 37.0 and -114.82 <= lon <= -109.04:
                    idx = 3
                else:
                    idx = 2
            elif col_val < data[i + 2]:
                idx = 1
            else:
                idx = 0
        tz_name = names[idx] if 0 <= idx < len(names) else "Outside"
        print("  {:20s} ({:7.2f}, {:7.2f}) -> {} ({})".format(
            name, lat, lon, idx, tz_name))


if __name__ == '__main__':
    main()
